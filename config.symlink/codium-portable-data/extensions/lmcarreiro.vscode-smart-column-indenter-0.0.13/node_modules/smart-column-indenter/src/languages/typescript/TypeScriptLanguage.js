"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Language_1 = require("../Language");
const TypeScriptScanner_1 = require("./TypeScriptScanner");
const TypeScriptToken_1 = require("./TypeScriptToken");
const intersection = require("lodash.intersection");
class TypeScriptLanguage extends Language_1.default {
    constructor() {
        super(...arguments);
        this.headOrTailMissingToken = ",";
    }
    token2string(token) {
        if (TypeScriptScanner_1.nestableKinds.some(t => t[0] === token.syntaxKind || t[1] === token.syntaxKind)) {
            return `${token.content}[${token.level}]`;
        }
        else if (TypeScriptScanner_1.SyntaxKind.FirstPunctuation <= token.syntaxKind && token.syntaxKind <= TypeScriptScanner_1.SyntaxKind.LastPunctuation) {
            return token.content;
        }
        else if (TypeScriptScanner_1.SyntaxKind.FirstLiteralToken <= token.syntaxKind && token.syntaxKind <= TypeScriptScanner_1.SyntaxKind.LastLiteralToken) {
            return token.kind;
        }
        else if (token.syntaxKind === TypeScriptScanner_1.SyntaxKind.Identifier) {
            return this.wordsIntersection.has(token.content || "") ? `${token.kind}[${token.content}]` : token.kind;
        }
        else {
            return token.content;
        }
    }
    stringify(lines) {
        const stringifiedLines = lines.map(line => "");
        for (let column = 0; column < lines[0].length; column++) {
            const lengths = lines.map(l => {
                const tokens = l[column];
                return tokens.map(t => t.content.length).reduce((a, b) => a + b, 0);
            });
            const maxLength = Math.max(...lengths);
            for (let i = 0; i < lines.length; i++) {
                const tokens = lines[i][column];
                const content = tokens.map(t => t.content).join("");
                stringifiedLines[i] += this.pad(content, maxLength);
            }
        }
        return stringifiedLines;
    }
    tokenize(linesOfCode) {
        const linesOfTokens = linesOfCode.map(line => {
            const scanner = new TypeScriptScanner_1.default(line);
            const tokens = [];
            while (!scanner.endOfLine()) {
                tokens.push(scanner.getToken());
            }
            return tokens;
        });
        const wordsByLine = linesOfTokens.map(line => line.filter(t => t.syntaxKind === TypeScriptScanner_1.SyntaxKind.Identifier).map(t => t.content));
        this.wordsIntersection = new Set(intersection(...wordsByLine));
        return linesOfTokens;
    }
    preProcessInput(lines) {
        let processedLines = lines;
        processedLines = this.removeHeadOrTailMissingToken(processedLines, ",");
        processedLines = processedLines.map(line => line.filter(t => t.syntaxKind !== TypeScriptScanner_1.SyntaxKind.WhitespaceTrivia));
        return processedLines;
    }
    preProcessOutput(lines) {
        return lines.map(line => line.map(t => this.transformOutputToken(t)));
    }
    transformOutputToken(token) {
        //This is needed because some places already have multiples whitespaces
        if (token.syntaxKind === TypeScriptScanner_1.SyntaxKind.WhitespaceTrivia && token.content.match(/\s\s+/)) {
            return new TypeScriptToken_1.default(token.syntaxKind, " ", token.level);
        }
        return token;
    }
}
exports.default = TypeScriptLanguage;
//# sourceMappingURL=TypeScriptLanguage.js.map