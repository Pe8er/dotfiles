"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TypeScriptToken_1 = require("./TypeScriptToken");
const typescript_1 = require("typescript");
exports.SyntaxKind = typescript_1.SyntaxKind;
let nestableKinds = [
    [typescript_1.SyntaxKind.OpenParenToken, typescript_1.SyntaxKind.CloseParenToken],
    [typescript_1.SyntaxKind.OpenBracketToken, typescript_1.SyntaxKind.CloseBracketToken],
    [typescript_1.SyntaxKind.OpenBraceToken, typescript_1.SyntaxKind.CloseBraceToken],
    [typescript_1.SyntaxKind.TemplateHead, typescript_1.SyntaxKind.TemplateTail],
];
exports.nestableKinds = nestableKinds;
class TypeScriptScanner {
    constructor(lineOfcode) {
        this.states = [];
        this.tscScanner = typescript_1.createScanner(typescript_1.ScriptTarget.ES2017, false, typescript_1.LanguageVariant.Standard);
        this.lineOfcode = lineOfcode;
        this.tscScanner.setText(this.lineOfcode);
        let tokens = [];
    }
    getToken() {
        this.tscScanner.scan();
        let token = this.tscScanner.getToken();
        let level = this.states.length;
        //TODO: handle regex token
        if (nestableKinds.some(k => token === k[0])) {
            this.states.push(token);
        }
        else if (nestableKinds.some(k => token === k[1])) {
            const state = this.states[this.states.length - 1];
            if (state === typescript_1.SyntaxKind.TemplateHead && token === typescript_1.SyntaxKind.CloseBraceToken) {
                token = this.tscScanner.reScanTemplateToken();
            }
            if (nestableKinds.some(k => state === k[0] && token === k[1])) {
                this.states.pop();
                level--;
            }
        }
        return new TypeScriptToken_1.default(token, this.tscScanner.getTokenText(), level);
    }
    endOfLine() {
        return this.tscScanner.getTextPos() === this.lineOfcode.length;
    }
}
exports.default = TypeScriptScanner;
//# sourceMappingURL=TypeScriptScanner.js.map